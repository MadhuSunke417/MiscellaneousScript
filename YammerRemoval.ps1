#CMTraceLog Function formats logging in CMTrace style
#Logfile generated by this script
#date 13 04 2024
$LogFolder = "C:\Windows\InstLogs"
$logfile   = "$LogFolder\RemoveYammerfromAllUserProfiles.log"
$div = "="*50

function CMTraceLog {
         [CmdletBinding()]
    Param (
		    [Parameter(Mandatory=$false)]
		    $Message,
 
		    [Parameter(Mandatory=$false)]
		    $ErrorMessage,
 
		    [Parameter(Mandatory=$false)]
		    $Component = "RemoveYammer",
 
		    [Parameter(Mandatory=$false)]
		    [int]$Type,
		
		    [Parameter(Mandatory=$true)]
		    $LogFile
	    )
    <#
    Type: 1 = Normal, 2 = Warning (yellow), 3 = Error (red)
    #>
	    $Time = Get-Date -Format "HH:mm:ss.ffffff"
	    $Date = Get-Date -Format "MM-dd-yyyy"
 
	    if ($ErrorMessage -ne $null) {$Type = 3}
	    if ($Component -eq $null) {$Component = " "}
	    if ($Type -eq $null) {$Type = 1}
 
	    $LogMessage = "<![LOG[$Message $ErrorMessage" + "]LOG]!><time=`"$Time`" date=`"$Date`" component=`"$Component`" context=`"`" type=`"$Type`" thread=`"`" file=`"`">"
	    $LogMessage | Out-File -Append -Encoding UTF8 -FilePath $LogFile
    }

function Execute-AsLoggedOnUser($Command,$Hidden=$true) {
    <#
    .SYNOPSIS
    Function that can execute powershell in the context of the logged-in user.
    .DESCRIPTION
    This function will use advanced API's to get the access token of the currently logged-in user, in order to execute a script in the users context.
    This is useful for scripts that are run in the local system users context.
    .REQUIREMENTS
    This script myst be run from the context of the SYSTEM account.
    Designes to be run by Intune or SCCM Agent.
    Absolute paths required.
    .EXAMPLE
    Running a powershell script visible to the user
        $userCommand = '-file c:\windows\temp\script.ps1'
        executeAsLoggedOnUser -Command $userCommand -Hidden $false
    .EXAMPLE
    Running a powershell command hidden from the user (hidden is default true)
        $userCommand = '-command &{remove-item c:\temp\secretfile.txt}'
        executeAsLoggedOnUser -Command $userCommand
    .COPYRIGHT
    MIT License, feel free to distribute and use as you like, please leave author information.
    .AUTHOR
    Michael Mardahl - @michael_mardahl on twitter - BLOG: https://www.iphase.dk
    C# borrowed from the awesome Justin Myrray (https://github.com/murrayju/CreateProcessAsUser)
    .DISCLAIMER
    This function is provided AS-IS, with no warranty - Use at own risk!
    #>

$csharpCode = @"
    using System;  
    using System.Runtime.InteropServices;
    namespace murrayju.ProcessExtensions  
    {
        public static class ProcessExtensions
        {
            #region Win32 Constants
            private const int CREATE_UNICODE_ENVIRONMENT = 0x00000400;
            private const int CREATE_NO_WINDOW = 0x08000000;
            private const int CREATE_NEW_CONSOLE = 0x00000010;
            private const uint INVALID_SESSION_ID = 0xFFFFFFFF;
            private static readonly IntPtr WTS_CURRENT_SERVER_HANDLE = IntPtr.Zero;
            #endregion
            #region DllImports
            [DllImport("advapi32.dll", EntryPoint = "CreateProcessAsUser", SetLastError = true, CharSet = CharSet.Ansi, CallingConvention = CallingConvention.StdCall)]
            private static extern bool CreateProcessAsUser(
                IntPtr hToken,
                String lpApplicationName,
                String lpCommandLine,
                IntPtr lpProcessAttributes,
                IntPtr lpThreadAttributes,
                bool bInheritHandle,
                uint dwCreationFlags,
                IntPtr lpEnvironment,
                String lpCurrentDirectory,
                ref STARTUPINFO lpStartupInfo,
                out PROCESS_INFORMATION lpProcessInformation);
            [DllImport("advapi32.dll", EntryPoint = "DuplicateTokenEx")]
            private static extern bool DuplicateTokenEx(
                IntPtr ExistingTokenHandle,
                uint dwDesiredAccess,
                IntPtr lpThreadAttributes,
                int TokenType,
                int ImpersonationLevel,
                ref IntPtr DuplicateTokenHandle);
            [DllImport("userenv.dll", SetLastError = true)]
            private static extern bool CreateEnvironmentBlock(ref IntPtr lpEnvironment, IntPtr hToken, bool bInherit);
            [DllImport("userenv.dll", SetLastError = true)]
            [return: MarshalAs(UnmanagedType.Bool)]
            private static extern bool DestroyEnvironmentBlock(IntPtr lpEnvironment);
            [DllImport("kernel32.dll", SetLastError = true)]
            private static extern bool CloseHandle(IntPtr hSnapshot);
            [DllImport("kernel32.dll")]
            private static extern uint WTSGetActiveConsoleSessionId();
            [DllImport("Wtsapi32.dll")]
            private static extern uint WTSQueryUserToken(uint SessionId, ref IntPtr phToken);
            [DllImport("wtsapi32.dll", SetLastError = true)]
            private static extern int WTSEnumerateSessions(
                IntPtr hServer,
                int Reserved,
                int Version,
                ref IntPtr ppSessionInfo,
                ref int pCount);
            #endregion
            #region Win32 Structs
            private enum SW
            {
                SW_HIDE = 0,
                SW_SHOWNORMAL = 1,
                SW_NORMAL = 1,
                SW_SHOWMINIMIZED = 2,
                SW_SHOWMAXIMIZED = 3,
                SW_MAXIMIZE = 3,
                SW_SHOWNOACTIVATE = 4,
                SW_SHOW = 5,
                SW_MINIMIZE = 6,
                SW_SHOWMINNOACTIVE = 7,
                SW_SHOWNA = 8,
                SW_RESTORE = 9,
                SW_SHOWDEFAULT = 10,
                SW_MAX = 10
            }
            private enum WTS_CONNECTSTATE_CLASS
            {
                WTSActive,
                WTSConnected,
                WTSConnectQuery,
                WTSShadow,
                WTSDisconnected,
                WTSIdle,
                WTSListen,
                WTSReset,
                WTSDown,
                WTSInit
            }
            [StructLayout(LayoutKind.Sequential)]
            private struct PROCESS_INFORMATION
            {
                public IntPtr hProcess;
                public IntPtr hThread;
                public uint dwProcessId;
                public uint dwThreadId;
            }
            private enum SECURITY_IMPERSONATION_LEVEL
            {
                SecurityAnonymous = 0,
                SecurityIdentification = 1,
                SecurityImpersonation = 2,
                SecurityDelegation = 3,
            }
            [StructLayout(LayoutKind.Sequential)]
            private struct STARTUPINFO
            {
                public int cb;
                public String lpReserved;
                public String lpDesktop;
                public String lpTitle;
                public uint dwX;
                public uint dwY;
                public uint dwXSize;
                public uint dwYSize;
                public uint dwXCountChars;
                public uint dwYCountChars;
                public uint dwFillAttribute;
                public uint dwFlags;
                public short wShowWindow;
                public short cbReserved2;
                public IntPtr lpReserved2;
                public IntPtr hStdInput;
                public IntPtr hStdOutput;
                public IntPtr hStdError;
            }
            private enum TOKEN_TYPE
            {
                TokenPrimary = 1,
                TokenImpersonation = 2
            }
            [StructLayout(LayoutKind.Sequential)]
            private struct WTS_SESSION_INFO
            {
                public readonly UInt32 SessionID;
                [MarshalAs(UnmanagedType.LPStr)]
                public readonly String pWinStationName;
                public readonly WTS_CONNECTSTATE_CLASS State;
            }
            #endregion
            // Gets the user token from the currently active session
            private static bool GetSessionUserToken(ref IntPtr phUserToken)
            {
                var bResult = false;
                var hImpersonationToken = IntPtr.Zero;
                var activeSessionId = INVALID_SESSION_ID;
                var pSessionInfo = IntPtr.Zero;
                var sessionCount = 0;
                // Get a handle to the user access token for the current active session.
                if (WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, ref pSessionInfo, ref sessionCount) != 0)
                {
                    var arrayElementSize = Marshal.SizeOf(typeof(WTS_SESSION_INFO));
                    var current = pSessionInfo;
                    for (var i = 0; i < sessionCount; i++)
                    {
                        var si = (WTS_SESSION_INFO)Marshal.PtrToStructure((IntPtr)current, typeof(WTS_SESSION_INFO));
                        current += arrayElementSize;
                        if (si.State == WTS_CONNECTSTATE_CLASS.WTSActive)
                        {
                            activeSessionId = si.SessionID;
                        }
                    }
                }
                // If enumerating did not work, fall back to the old method
                if (activeSessionId == INVALID_SESSION_ID)
                {
                    activeSessionId = WTSGetActiveConsoleSessionId();
                }
                if (WTSQueryUserToken(activeSessionId, ref hImpersonationToken) != 0)
                {
                    // Convert the impersonation token to a primary token
                    bResult = DuplicateTokenEx(hImpersonationToken, 0, IntPtr.Zero,
                        (int)SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation, (int)TOKEN_TYPE.TokenPrimary,
                        ref phUserToken);
                    CloseHandle(hImpersonationToken);
                }
                return bResult;
            }
            public static bool StartProcessAsCurrentUser(string cmdLine, bool visible, string appPath = null, string workDir = null)
            {
                var hUserToken = IntPtr.Zero;
                var startInfo = new STARTUPINFO();
                var procInfo = new PROCESS_INFORMATION();
                var pEnv = IntPtr.Zero;
                int iResultOfCreateProcessAsUser;
                startInfo.cb = Marshal.SizeOf(typeof(STARTUPINFO));
                try
                {
                    if (!GetSessionUserToken(ref hUserToken))
                    {
                        throw new Exception("StartProcessAsCurrentUser: GetSessionUserToken failed.");
                    }
                    uint dwCreationFlags = CREATE_UNICODE_ENVIRONMENT | (uint)(visible ? CREATE_NEW_CONSOLE : CREATE_NO_WINDOW);
                    startInfo.wShowWindow = (short)(visible ? SW.SW_SHOW : SW.SW_HIDE);
                    startInfo.lpDesktop = "winsta0\\default";
                    if (!CreateEnvironmentBlock(ref pEnv, hUserToken, false))
                    {
                        throw new Exception("StartProcessAsCurrentUser: CreateEnvironmentBlock failed.");
                    }
                    if (!CreateProcessAsUser(hUserToken,
                        appPath, // Application Name
                        cmdLine, // Command Line
                        IntPtr.Zero,
                        IntPtr.Zero,
                        false,
                        dwCreationFlags,
                        pEnv,
                        workDir, // Working directory
                        ref startInfo,
                        out procInfo))
                    {
                        throw new Exception("StartProcessAsCurrentUser: CreateProcessAsUser failed.\n");
                    }
                    iResultOfCreateProcessAsUser = Marshal.GetLastWin32Error();
                }
                finally
                {
                    CloseHandle(hUserToken);
                    if (pEnv != IntPtr.Zero)
                    {
                        DestroyEnvironmentBlock(pEnv);
                    }
                    CloseHandle(procInfo.hThread);
                    CloseHandle(procInfo.hProcess);
                }
                return true;
            }
        }
    }
"@
    # Compiling the source code as csharp
    $compilerParams = [System.CodeDom.Compiler.CompilerParameters]::new()
    $compilerParams.ReferencedAssemblies.AddRange(('System.Runtime.InteropServices.dll', 'System.dll'))
    $compilerParams.CompilerOptions = '/unsafe'
    $compilerParams.GenerateInMemory = $True
    Add-Type -TypeDefinition $csharpCode -Language CSharp -CompilerParameters $compilerParams
    # Adding powershell executeable to the command
    $Command = '{0}\System32\WindowsPowerShell\v1.0\powershell.exe -executionPolicy bypass {1}' -f $($env:windir),$Command
    # Adding double slashes to the command paths, as this is required.
    $Command = $Command.Replace("\","\\")
    # Execute a process as the currently logged on user. 
    # Absolute paths required if running as SYSTEM!
    if($Hidden) { #running the command hidden
        $runCommand = [murrayju.ProcessExtensions.ProcessExtensions]::StartProcessAsCurrentUser($Command,$false)
    }else{ #running the command visible
        $runCommand = [murrayju.ProcessExtensions.ProcessExtensions]::StartProcessAsCurrentUser($Command,$true)
    }

    if ($runCommand) {
        return "Executed `"$Command`" as loggedon user"
    } else {
        throw "Something went wrong when executing process as currently logged-on user"
    }
}

function Uninstall-YammerCurrentUser() {

    Write-Verbose -Verbose -Message "Running Uninstall-YammerCurrentUser function"
    CMTraceLog -Message "Running Uninstall-YammerCurrentUser function" -Type 1 -LogFile $logfile
    # Getting all user profiles on the computer
    $userProfiles = Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\*" | Where-Object {$_.PSChildName -match "S-1-5-21-(\d+-?){4}$"} | Select-Object @{Name="SID"; Expression={$_.PSChildName}}, @{Name="UserHive";Expression={"$($_.ProfileImagePath)\NTuser.dat"}}
    foreach ($userProfile in $userProfiles) {
        # Formatting the username in a separate variable
        $userName = $userProfile.UserHive.Split("\")[2]
        $registryPath = "Registry::HKEY_USERS\$($UserProfile.SID)\Software\Microsoft\Windows\CurrentVersion\Uninstall"
        CMTraceLog -Message "****$userName SID -> $($UserProfile.SID)" -Type 1 -LogFile $logfile
        if (Test-Path -Path $registryPath) {
            $installedYammerApps = Get-ChildItem -Path $registryPath -Recurse | Get-ItemProperty | Where-Object {$_.DisplayName -eq "Yammer" } 
            if ($installedYammerApps) {
                Write-Verbose -Verbose -Message "Installed Yammer applications found in HKCU for user: $userName"
                CMTraceLog -Message "Installed Yammer applications found in HKCU for user: $userName" -Type 1 -LogFile $logfile
                foreach ($YammerApp in $installedYammerApps) {
                    if ($YammerApp.UninstallString) {
                        
                        $userCommand = '-command &{Start-Process "C:\Users\USERNAME\AppData\Local\yammerdesktop\Update.exe" -ArgumentList "--uninstall","-s" -Wait}'
                        $userCommand = $userCommand -replace "USERNAME",$userName 
                        try {
                            if(Get-Process -Name Yammer -ErrorAction SilentlyContinue){
                            CMTraceLog -Message "Yammer Process running and trying to close...." -Type 1 -LogFile $logfile
                            Stop-Process -Name Yammer -Force -ErrorAction SilentlyContinue
                            }
                            Write-Verbose -Verbose -Message "Uninstalling application: $($YammerApp.DisplayName) as the logged on user: $userName"
                            CMTraceLog -Message "Uninstalling application: $($YammerApp.DisplayName) as the logged on user: $userName" -Type 1 -LogFile $logfile
                            Execute-AsLoggedOnUser -Command $userCommand

                            #Registry Cleanup
                            $delP =  "registry::HKEY_USERS\$($UserProfile.SID)\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\"
                            try{
                            Get-ChildItem -Path $delP -Recurse -ErrorAction Stop | Get-ItemProperty | Where-Object {$_.DisplayName -eq "Yammer" } | Remove-Item -Recurse -ErrorAction Stop
                            }catch{}
                            
                            #Folder Cleanup
                            Remove-Item -Path "C:\Users\$userName\AppData\Local\yammerdesktop" -Recurse -Force -ErrorAction SilentlyContinue
                        }
                        catch {
                            Write-Error -Message "Failed to uninstall application: $($YammerApp.DisplayName) for user: $userName"
                            CMTraceLog -Message "Failed to uninstall application: $($YammerApp.DisplayName) for user: $userName" -Type 2 -LogFile $logfile
                        }
                    }
                }
            }
            else {
                Write-Verbose -Verbose -Message "No Yammer applications found in HKCU for user: $userName"
                CMTraceLog -Message "No Yammer applications found in HKCU for user: $userName" -Type 1 -LogFile $logfile
            }
        }
        else {
            Write-Verbose -Verbose -Message "Registry path not found for user: $userName"
            CMTraceLog -Message "Registry path not found for user: $userName" -Type 1 -LogFile $logfile
        }
    }
}

CMTraceLog -Message $div -Type 1 -LogFile $logfile
try {
    Write-Verbose -Verbose -Message "Script is running"
    CMTraceLog -Message "Script is running" -Type 1 -LogFile $logfile
    Uninstall-YammerCurrentUser
}

catch {
    Write-Verbose -Verbose -Message "Something went wrong during running of the script"
    CMTraceLog -Message "Something went wrong during running of the script" -Type 2 -LogFile $logfile
}

finally {
    Write-Verbose -Verbose -Message "Script is done running" 
    CMTraceLog -Message "Script is done running"  -Type 1 -LogFile $logfile
}
CMTraceLog -Message $div -Type 1 -LogFile $logfile